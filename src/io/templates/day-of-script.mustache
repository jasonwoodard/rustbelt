<script>
(function () {
  'use strict';

  const SCORE_MIN = 0;
  const SCORE_MAX = 5;
  const SCORE_RANGE = SCORE_MAX - SCORE_MIN;
  const EPSILON = 1e-6;

  const appState = {
    itinerary: null,
    stops: [],
    currentIndex: 0,
    log: [],
    dayId: null,
    pendingDrop: null,
    awaitingAdvance: false,
    activeDecisionStopId: null,
    lastRecommendation: null,
    mqaMap: {
      Bust: 0.0,
      Average: 3.5,
      Good: 4.2,
      Exceptional: 5.0,
    },
    posteriorConfig: {
      priorStrength: 4,
      baseAlpha: EPSILON,
      baseBeta: EPSILON,
      credibleZ: 1.0,
      defaultScore: 3.5,
    },
    posteriorPool: {
      observedAlpha: 0,
      observedBeta: 0,
      observationCount: 0,
      totalObservedQuality: 0,
      lastObservation: null,
    },
  };

  document.addEventListener('DOMContentLoaded', init);

  function createMapsUrl(stop) {
    if (!stop) return null;

    const queryParts = [];
    const hasLat = typeof stop.lat === 'number' && Number.isFinite(stop.lat);
    const hasLon = typeof stop.lon === 'number' && Number.isFinite(stop.lon);
    if (hasLat && hasLon) {
      queryParts.push(`${stop.lat},${stop.lon}`);
    }

    if (typeof stop.name === 'string' && stop.name.trim()) {
      queryParts.push(stop.name.trim());
    }

    if (typeof stop.address === 'string' && stop.address.trim()) {
      queryParts.push(stop.address.trim());
    }

    if (queryParts.length === 0) {
      return null;
    }

    const query = encodeURIComponent(queryParts.join(' '));
    return `https://www.google.com/maps/search/?api=1&query=${query}`;
  }

  function init() {
    const dataElement = document.getElementById('itinerary-data');
    if (!dataElement) {
      console.error('Itinerary data script tag not found.');
      return;
    }

    try {
      appState.itinerary = JSON.parse(dataElement.textContent || '{}');
    } catch (err) {
      console.error('Failed to parse itinerary JSON.', err);
      return;
    }

    const days = Array.isArray(appState.itinerary?.days)
      ? appState.itinerary.days
      : [];
    const activeDayId = document.body?.dataset?.activeDayId;
    const day =
      (activeDayId && days.find((d) => d?.dayId === activeDayId)) ||
      days.find((d) => Array.isArray(d?.stops) && d.stops.length > 0) ||
      days.find(() => true);
    if (!day) {
      console.error('Unable to determine active day for itinerary.');
      return;
    }

    appState.dayId = day.dayId ?? null;
    if (document.body && appState.dayId) {
      document.body.dataset.activeDayId = appState.dayId;
    }

    const dayLabel = document.getElementById('active-day-label');
    if (dayLabel && day.dayId) {
      dayLabel.textContent = `Day ${day.dayId}`;
    }

    const stops = Array.isArray(day.stops) ? day.stops : [];
    appState.stops = stops
      .filter((stop) => stop.type === 'store')
      .map((stop) => ({
        ...stop,
        status: 'tovisit',
        posterior: createPosterior(stop.score),
        mapsUrl: createMapsUrl(stop),
      }));

    appState.currentIndex = appState.stops.findIndex((s) => s.status === 'tovisit');
    if (appState.currentIndex === -1) {
      appState.currentIndex = appState.stops.length;
    }

    const runInfo = document.getElementById('run-info');
    if (runInfo && appState.itinerary) {
      const existing = runInfo.textContent?.trim();
      if (!existing) {
        const runId = appState.itinerary.runId ?? 'Unknown Run';
        const runNote = appState.itinerary.runNote ? ` - ${appState.itinerary.runNote}` : '';
        runInfo.textContent = `Run ID: ${runId}${runNote}`;
      }
    }

    setupMQAOptions();
    renderAll();
    addEventListeners();
  }

  function setupMQAOptions() {
    const container = document.getElementById('mqa-select');
    if (!container) return;
    container.innerHTML = '';
    Object.entries(appState.mqaMap).forEach(([key, value]) => {
      const div = document.createElement('div');
      div.className = 'flex items-center p-3 rounded-lg border border-stone-200 hover:bg-stone-50';
      div.innerHTML = `
        <input id="mqa-${key.toLowerCase()}" type="radio" name="mqa" value="${key}" class="h-4 w-4 text-teal-600 border-stone-300 focus:ring-teal-500">
        <label for="mqa-${key.toLowerCase()}" class="ml-3 block text-sm font-medium text-stone-700">
          ${key} <span class="text-xs text-stone-500">(${value.toFixed(1)})</span>
        </label>
      `;
      container.appendChild(div);
    });
  }

  function renderAll() {
    const currentStop = appState.stops[appState.currentIndex];
    const metrics = calculateMetrics(currentStop?.id);
    renderDashboard(metrics);
    renderItineraryList(currentStop);
    renderCurrentStore(currentStop);
    renderTripLog();
    refreshRecommendationDisplay();
  }

  function calculateMetrics(excludeId) {
    const totalStores = appState.stops.length;
    const visitedStores = appState.stops.filter((s) => s.status === 'visited').length;
    const overallAvgScore =
      totalStores > 0
        ? (
            appState.stops.reduce(
              (sum, s) => sum + (typeof s.score === 'number' ? s.score : appState.posteriorConfig.defaultScore),
              0,
            ) / totalStores
          ).toFixed(1)
        : '0.0';

    const poolPosterior = computeRemainingPoolPosterior(excludeId);
    const currentStop = appState.stops[appState.currentIndex];

    return {
      totalStores,
      visitedStores,
      overallAvgScore,
      poolPosterior,
      currentPosterior: currentStop ? currentStop.posterior : null,
      expectedRemQuality: poolPosterior ? poolPosterior.mean.toFixed(2) : '0.0',
    };
  }

  function renderDashboard(metrics) {
    const {
      totalStores,
      visitedStores,
      overallAvgScore,
      poolPosterior,
      currentPosterior,
    } = metrics;

    setText('dashboard-total-stores', totalStores);
    setText('dashboard-stores-visited', visitedStores);
    setText('dashboard-avg-jscore', overallAvgScore);
    setText(
      'dashboard-expected-quality',
      poolPosterior ? poolPosterior.mean.toFixed(2) : '--',
    );
    setText(
      'dashboard-pool-uncertainty',
      poolPosterior ? `±${poolPosterior.std.toFixed(2)}` : '±--',
    );
    setText(
      'dashboard-current-mean',
      currentPosterior ? currentPosterior.mean.toFixed(2) : '--',
    );
    setText(
      'dashboard-current-uncertainty',
      currentPosterior ? `±${currentPosterior.std.toFixed(2)}` : '±--',
    );
    const currentUcbText =
      currentPosterior && typeof currentPosterior.upper === 'number'
        ? currentPosterior.upper.toFixed(2)
        : '--';
    const remainingUcbText =
      poolPosterior && typeof poolPosterior.upper === 'number'
        ? poolPosterior.upper.toFixed(2)
        : '--';
    setText('dashboard-current-ucb', currentUcbText);
    setText('dashboard-remaining-ucb', remainingUcbText);
  }

  function renderItineraryList(currentStop) {
    const container = document.getElementById('itinerary-list');
    if (!container) return;
    container.innerHTML = '';
    appState.stops.forEach((stop, index) => {
      const awaitingStopId = appState.awaitingAdvance ? appState.activeDecisionStopId : null;
      const isAwaitingCurrent =
        awaitingStopId != null && String(stop.id) === String(awaitingStopId);
      const isCurrent =
        (currentStop && stop.id === currentStop.id && stop.status === 'tovisit') || isAwaitingCurrent;
      const div = document.createElement('div');
      div.id = `row-${stop.id}`;
      div.className = `p-3 rounded-md transition-all duration-300 ease-in-out status-${stop.status} ${
        isCurrent ? 'ring-2 ring-teal-500 shadow-md' : 'shadow-sm'
      }`;
      const posteriorMean = stop.posterior ? stop.posterior.mean.toFixed(2) : formatScore(stop.score);
      const posteriorStd = stop.posterior ? stop.posterior.std.toFixed(2) : '0.00';
      const initialScore = formatScore(stop.score);
      const statusLabel =
        stop.status === 'visited'
          ? `Visited – ${stop.mqa ?? 'n/a'}`
          : stop.status === 'dropped'
          ? 'Dropped'
          : 'To Visit';
      const nameMarkup = stop.mapsUrl
        ? `<a class="store-link" href="${stop.mapsUrl}" target="_blank" rel="noopener noreferrer">${stop.name}</a>`
        : stop.name;
      const dropButtonHtml =
        stop.status === 'tovisit'
          ? `<button type="button" class="drop-store-button mt-1 transition-colors" data-drop-stop-id="${stop.id}">Drop store</button>`
          : '';
      div.innerHTML = `
        <div class="flex justify-between items-start gap-3">
          <div>
            <p class="font-semibold">${nameMarkup}</p>
            <p class="text-xs text-stone-500">${statusLabel}</p>
          </div>
          <div class="flex flex-col items-end text-right gap-2">
            <div class="text-right">
              <p class="font-mono text-sm bg-stone-200 text-stone-700 px-2 py-1 rounded">${posteriorMean}</p>
              <div class="mt-2 space-y-1 leading-tight">
                <div>
                  <p class="text-xs uppercase tracking-wide text-stone-600">
                  Uncertainty&nbsp;:&nbsp;±${posteriorStd}</p>
                </div>
                <div>
                  <p class="text-xs uppercase tracking-wide text-stone-600">
                    Initial Score&nbsp;:&nbsp;${initialScore}</p>
                </div>
              </div>
            </div>
            ${dropButtonHtml}
          </div>
        </div>
      `;
      container.appendChild(div);
    });
  }

  function renderCurrentStore(currentStop) {
    const nameEl = document.getElementById('current-store-name');
    const form = document.getElementById('mqa-form');
    if (!nameEl || !form) return;

    const awaitingCurrent =
      appState.awaitingAdvance &&
      currentStop &&
      String(currentStop.id) === String(appState.activeDecisionStopId);

    if (!currentStop || (currentStop.status !== 'tovisit' && !awaitingCurrent)) {
      nameEl.textContent = 'Trip Complete!';
      form.style.display = 'none';
      setText('timeline-arrive-time', '--:--');
      setText('timeline-mqa-time', '--:--');
      return;
    }

    form.style.display = awaitingCurrent ? 'none' : 'block';

    const nameMarkup = currentStop.mapsUrl
      ? `<a class="store-link" href="${currentStop.mapsUrl}" target="_blank" rel="noopener noreferrer">${currentStop.name}</a>`
      : currentStop.name;
    nameEl.innerHTML = nameMarkup;

    const [arriveH, arriveM] = currentStop.arrive.split(':').map(Number);
    const mqaTime = new Date();
    mqaTime.setHours(arriveH, arriveM + 30, 0, 0);
    const mqaH = String(mqaTime.getHours()).padStart(2, '0');
    const mqaM = String(mqaTime.getMinutes()).padStart(2, '0');

    setText('timeline-arrive-time', currentStop.arrive);
    setText('timeline-mqa-time', `${mqaH}:${mqaM}`);
  }

  function renderTripLog() {
    const container = document.getElementById('trip-log');
    if (!container) return;

    if (appState.log.length === 0) {
      container.innerHTML = '<p class="text-stone-500">Your decisions will appear here.</p>';
      return;
    }

    container.innerHTML = '';
    appState.log.forEach((entry) => {
      const div = document.createElement('div');
      div.className = 'p-2 border-b border-stone-100';
      const posterior = entry.posterior;
      const pool = entry.pool;
      const mqaValueText = entry.mqaValue != null ? ` (${entry.mqaValue.toFixed(1)})` : '';
      const zScoreText = entry.zScore != null ? ` | z=${entry.zScore.toFixed(2)}` : '';
      const nameHtml = entry.mapsUrl
        ? `<a class="store-link" href="${entry.mapsUrl}" target="_blank" rel="noopener noreferrer">${entry.name}</a>`
        : entry.name;
      const currentUcbText =
        entry.currentUcb != null && Number.isFinite(entry.currentUcb)
          ? entry.currentUcb.toFixed(2)
          : '--';
      const remainingUcbText =
        entry.remainingUcb != null && Number.isFinite(entry.remainingUcb)
          ? entry.remainingUcb.toFixed(2)
          : '--';
      div.innerHTML = `
        <p class="font-medium">${nameHtml}</p>
        <p class="text-stone-600">MQA: <span class="font-semibold">${entry.mqa}</span>${mqaValueText} → Decision: <span class="font-semibold">${entry.decision}</span></p>
        <p class="text-xs text-stone-500">Posterior μ=${posterior.mean.toFixed(2)} σ=${posterior.std.toFixed(2)} | Upper Confidence Bound (UCB)=${currentUcbText} | Pool μ=${pool.mean.toFixed(2)} σ=${pool.std.toFixed(2)} | Pool Upper Confidence Bound (UCB)=${remainingUcbText}${
        zScoreText ? ` ${zScoreText}` : ''
      }</p>
      `;
      container.appendChild(div);
    });
    container.scrollTop = container.scrollHeight;
  }

  function refreshRecommendationDisplay() {
    if (!appState.lastRecommendation) {
      return;
    }

    const { recommendation, meta, currentPosterior, poolPosterior } = appState.lastRecommendation;
    updateRecommendationDisplay(recommendation, meta, currentPosterior, poolPosterior);
  }

  function processDecision(mqaKey) {
    const currentStop = appState.stops[appState.currentIndex];
    if (!currentStop) return;

    const mqaValue = appState.mqaMap[mqaKey];
    if (typeof mqaValue !== 'number') {
      console.warn('Unknown MQA key selected:', mqaKey);
      return;
    }

    updateStopPosterior(currentStop, mqaValue);
    updatePoolObservation(mqaValue);

    const poolPosterior = computeRemainingPoolPosterior(currentStop.id);
    const decisionMeta = getRecommendation(
      currentStop.posterior,
      poolPosterior,
      mqaKey,
      mqaValue,
    );
    const recommendation = decisionMeta.decision;
    const posteriorSummary = serializePosterior(currentStop.posterior);
    const poolSummary = poolPosterior ? serializePool(poolPosterior) : null;
    const recommendationMeta = { ...decisionMeta };

    appState.lastRecommendation = {
      recommendation,
      meta: recommendationMeta,
      currentPosterior: posteriorSummary,
      poolPosterior: poolSummary,
    };

    updateRecommendationDisplay(recommendation, recommendationMeta, posteriorSummary, poolSummary);

    currentStop.mqa = mqaKey;
    currentStop.mqaValue = mqaValue;
    currentStop.decision = recommendation;
    currentStop.decisionReason = decisionMeta.reason;
    currentStop.status = 'visited';
    currentStop.posteriorSummary = {
      ...posteriorSummary,
      diff: decisionMeta.diff,
      zScore: decisionMeta.zScore,
      currentUcb: decisionMeta.currentUcb ?? null,
      remainingUcb: decisionMeta.remainingUcb ?? null,
    };

    const shouldPauseBeforeAdvancing = recommendation === 'Stay' && mqaKey === 'Exceptional';
    appState.awaitingAdvance = shouldPauseBeforeAdvancing;
    appState.activeDecisionStopId = shouldPauseBeforeAdvancing ? currentStop.id : null;

    appState.log.push({
      name: currentStop.name,
      mapsUrl: currentStop.mapsUrl,
      mqa: mqaKey,
      mqaValue,
      decision: recommendation,
      decisionReason: decisionMeta.reason,
      diff: decisionMeta.diff,
      zScore: decisionMeta.zScore,
      currentUcb: decisionMeta.currentUcb ?? null,
      remainingUcb: decisionMeta.remainingUcb ?? null,
      observationCount: decisionMeta.observationCount ?? null,
      posterior: posteriorSummary,
      pool: poolSummary ?? serializePool(poolPosterior),
      timestamp: new Date().toISOString(),
    });

    renderAll();

    if (recommendation === 'Stay' && mqaKey === 'Exceptional') {
      handleOverrun();
    } else {
      advanceToNextStore();
    }
  }

  function updateRecommendationDisplay(recommendation, meta, currentPosterior, poolPosterior) {
    const display = document.getElementById('recommendation-display');
    if (!display) return;
    const diffText =
      meta.diff != null
        ? `ΔUpper Confidence Bound (UCB)=${meta.diff.toFixed(2)}`
        : '';
    const zText = meta.zScore != null && Number.isFinite(meta.zScore) ? `z=${meta.zScore.toFixed(2)}` : '';
    const reason = humanizeReason(meta.reason);
    const currentUcbText =
      meta.currentUcb != null && Number.isFinite(meta.currentUcb)
        ? meta.currentUcb.toFixed(2)
        : '--';
    const currentSummary = currentPosterior
      ? `Current μ=${currentPosterior.mean.toFixed(2)} σ=${currentPosterior.std.toFixed(2)} Upper Confidence Bound (UCB)=${currentUcbText}`
      : '';
    const poolUcbText =
      meta.remainingUcb != null && Number.isFinite(meta.remainingUcb)
        ? meta.remainingUcb.toFixed(2)
        : '--';
    const poolSummary = poolPosterior
      ? `Pool μ=${poolPosterior.mean.toFixed(2)} σ=${poolPosterior.std.toFixed(2)} Upper Confidence Bound (UCB)=${poolUcbText}`
      : '';

    const metaLine = [reason, diffText, zText].filter(Boolean).join(' · ');
    const summaryLine = [currentSummary, poolSummary].filter(Boolean).join(' | ');

    let pendingDropMarkup = '';
    const pendingDrop = appState.pendingDrop;
    if (pendingDrop) {
      const pendingStop = appState.stops.find(
        (s) => String(s.id) === String(pendingDrop.stopId ?? pendingDrop.id),
      );
      if (pendingStop && pendingStop.status === 'tovisit') {
        const nameMarkup = pendingStop.mapsUrl
          ? `<a class="store-link" href="${pendingStop.mapsUrl}" target="_blank" rel="noopener noreferrer">${pendingStop.name}</a>`
          : pendingStop.name;
        const posteriorMean = pendingStop.posterior
          ? pendingStop.posterior.mean.toFixed(2)
          : formatScore(pendingStop.score);
        const posteriorStd = pendingStop.posterior
          ? pendingStop.posterior.std.toFixed(2)
          : '0.00';
        const initialScore = formatScore(pendingStop.score);
        const statusLabel =
          pendingStop.status === 'visited'
            ? `Visited – ${pendingStop.mqa ?? 'n/a'}`
            : pendingStop.status === 'dropped'
            ? 'Dropped'
            : 'To Visit';
        const scheduleParts = [];
        if (pendingStop.arrive) {
          scheduleParts.push(`Arrive ${pendingStop.arrive}`);
        }
        if (pendingStop.depart) {
          scheduleParts.push(`Depart ${pendingStop.depart}`);
        }
        const scheduleMarkup =
          scheduleParts.length > 0
            ? `<p class="pending-drop-store-schedule">${scheduleParts.join(' · ')}</p>`
            : '';
        const storeSummaryMarkup = `
          <div class="pending-drop-store p-3 rounded-md shadow-sm">
            <div class="flex justify-between items-start gap-3">
              <div>
                <p class="font-semibold pending-drop-store-name">${nameMarkup}</p>
                <p class="text-xs text-stone-500 pending-drop-store-status">${statusLabel}</p>
              </div>
              <div class="flex flex-col items-end text-right gap-2">
                <div class="text-right">
                  <p class="font-mono text-sm bg-stone-200 text-stone-700 px-2 py-1 rounded pending-drop-store-mean">${posteriorMean}</p>
                  <div class="mt-2 space-y-1 leading-tight pending-drop-store-metrics">
                    <p class="text-xs uppercase tracking-wide text-stone-600">Uncertainty&nbsp;:&nbsp;±${posteriorStd}</p>
                    <p class="text-xs uppercase tracking-wide text-stone-600">Initial Score&nbsp;:&nbsp;${initialScore}</p>
                  </div>
                </div>
              </div>
            </div>
            ${scheduleMarkup}
          </div>
        `;

        pendingDropMarkup = `
      <div class="pending-drop-panel mt-4 rounded-lg p-4">
        <p class="pending-drop-title">Extend your stay?</p>
        <p class="pending-drop-subtitle">Drop the lowest-rated remaining store to stay longer.</p>
        ${storeSummaryMarkup}
        <div class="pending-drop-actions">
          <button
            type="button"
            class="pending-drop-action pending-drop-action--danger"
            data-action="confirm-pending-drop"
            data-stop-id="${pendingStop.id}"
          >
            Drop store?
          </button>
          <button
            type="button"
            class="pending-drop-action pending-drop-action--secondary"
            data-action="cancel-pending-drop"
          >
            Do NOT Drop
          </button>
        </div>
      </div>
    `;
      } else {
        appState.pendingDrop = null;
      }
    }

    let advanceControlsMarkup = '';
    const awaitingAdvance = appState.awaitingAdvance && appState.activeDecisionStopId != null;
    if (awaitingAdvance) {
      const nextDisabled = !!appState.pendingDrop;
      const disabledAttr = nextDisabled ? 'disabled aria-disabled="true"' : '';
      const baseButtonClass =
        'next-store-button rounded-md px-3 py-2 text-sm font-semibold focus:outline-none focus:ring-2 focus:ring-offset-1';
      const buttonClass = nextDisabled
        ? `${baseButtonClass} bg-stone-300 text-stone-500 cursor-not-allowed focus:ring-stone-300`
        : `${baseButtonClass} bg-teal-600 text-white shadow hover:bg-teal-700 focus:ring-teal-500`;
      const helperText = nextDisabled
        ? '<p class="text-xs text-stone-500">Resolve the drop decision before continuing.</p>'
        : '';
      advanceControlsMarkup = `
        <div class="mt-4 flex flex-col gap-2">
          <button type="button" class="${buttonClass}" data-action="advance-after-decision" ${disabledAttr}>
            Next store
          </button>
          ${helperText}
        </div>
      `;
    }

    const baseMarkup = `
      <p class="text-lg font-medium">Recommendation:</p>
      <p class="text-3xl font-bold recommendation-${recommendation.toLowerCase()}">${recommendation.toUpperCase()}</p>
      <p class="text-sm text-stone-600">${metaLine}</p>
      <p class="text-xs text-stone-500">${summaryLine}</p>
    `;

    display.innerHTML = `${baseMarkup}${pendingDropMarkup}${advanceControlsMarkup}`;

    if (pendingDropMarkup) {
      const confirmButton = display.querySelector('[data-action="confirm-pending-drop"]');
      if (confirmButton) {
        confirmButton.addEventListener('click', confirmPendingDrop);
      }
      const cancelButton = display.querySelector('[data-action="cancel-pending-drop"]');
      if (cancelButton) {
        cancelButton.addEventListener('click', cancelPendingDrop);
      }
    }
    if (advanceControlsMarkup) {
      const advanceButton = display.querySelector('[data-action="advance-after-decision"]');
      if (advanceButton) {
        advanceButton.addEventListener('click', handleAdvanceAfterDecision);
      }
    }
  }

  function dropStopById(stopId, reason) {
    const normalizedId = String(stopId);
    const stopIndex = appState.stops.findIndex((s) => String(s.id) === normalizedId);
    if (stopIndex === -1) return null;

    const stop = appState.stops[stopIndex];
    if (stop.status !== 'tovisit') {
      return null;
    }

    stop.status = 'dropped';
    stop.decision = 'Dropped';
    stop.decisionReason = reason;

    const posteriorSummary = serializePosterior(stop.posterior);
    stop.posteriorSummary = {
      ...posteriorSummary,
      diff: null,
      zScore: null,
      currentUcb: null,
      remainingUcb: null,
    };

    const poolSnapshot = serializePool(computeRemainingPoolPosterior());

    appState.log.push({
      name: stop.name,
      mapsUrl: stop.mapsUrl,
      mqa: 'N/A',
      mqaValue: null,
      decision: 'Dropped',
      decisionReason: reason,
      diff: null,
      zScore: null,
      currentUcb: null,
      remainingUcb: null,
      observationCount: null,
      posterior: posteriorSummary,
      pool: poolSnapshot,
      timestamp: new Date().toISOString(),
    });

    if (
      appState.pendingDrop &&
      String(appState.pendingDrop.stopId ?? appState.pendingDrop.id) === normalizedId
    ) {
      appState.pendingDrop = null;
    }

    return { stop, index: stopIndex };
  }

  function handleOverrun() {
    const remainingStops = appState.stops.filter((s) => s.status === 'tovisit');
    if (remainingStops.length === 0) {
      advanceToNextStore();
      return;
    }

    const lowestScoringStop = remainingStops.reduce((min, stop) =>
      stop.posterior.mean < min.posterior.mean ? stop : min,
    );

    appState.pendingDrop = {
      stopId: lowestScoringStop.id,
      reason: 'overrun-drop-lowest',
    };

    renderAll();
  }

  function confirmPendingDrop() {
    const pendingDrop = appState.pendingDrop;
    if (!pendingDrop) {
      return;
    }

    const stopId = pendingDrop.stopId ?? pendingDrop.id;
    const reason = pendingDrop.reason ?? 'pending-drop';

    if (stopId != null) {
      dropStopById(stopId, reason);
    }

    appState.pendingDrop = null;
    renderAll();
  }

  function cancelPendingDrop() {
    if (!appState.pendingDrop) {
      return;
    }

    appState.pendingDrop = null;
    renderAll();
  }

  function handleAdvanceAfterDecision() {
    if (appState.pendingDrop) {
      return;
    }

    advanceToNextStore();
  }

  function advanceToNextStore() {
    appState.pendingDrop = null;
    appState.awaitingAdvance = false;
    appState.activeDecisionStopId = null;
    appState.lastRecommendation = null;

    let nextIndex = appState.currentIndex + 1;
    while (nextIndex < appState.stops.length && appState.stops[nextIndex].status !== 'tovisit') {
      nextIndex += 1;
    }
    appState.currentIndex = nextIndex;

    const selectedRadio = document.querySelector('input[name="mqa"]:checked');
    if (selectedRadio) selectedRadio.checked = false;
    const display = document.getElementById('recommendation-display');
    if (display) display.innerHTML = '';

    renderAll();
  }

  function addEventListeners() {
    const decisionButton = document.getElementById('decision-button');
    if (decisionButton) {
      decisionButton.addEventListener('click', () => {
        const selectedMQA = document.querySelector('input[name="mqa"]:checked');
        if (!selectedMQA) {
          window.alert('Please select a Measured Quality Assessment (MQA).');
          return;
        }
        processDecision(selectedMQA.value);
      });
    }

    const bustButton = document.getElementById('bust-button');
    if (bustButton) {
      bustButton.addEventListener('click', () => {
        processDecision('Bust');
      });
    }

    const itineraryList = document.getElementById('itinerary-list');
    if (itineraryList) {
      itineraryList.addEventListener('click', (event) => {
        const target = event.target;
        if (!(target instanceof Element)) {
          return;
        }
        const button = target.closest('button[data-drop-stop-id]');
        if (!button) {
          return;
        }
        event.preventDefault();
        const stopId = button.getAttribute('data-drop-stop-id');
        if (!stopId) {
          return;
        }
        const stop = appState.stops.find((s) => String(s.id) === stopId);
        if (!stop || stop.status !== 'tovisit') {
          return;
        }
        const matchedPendingDrop =
          !!appState.pendingDrop &&
          String(appState.pendingDrop.stopId ?? appState.pendingDrop.id) === stopId;
        const confirmed = window.confirm(
          `Drop ${stop.name}?\n\nThis will mark the store as dropped.`,
        );
        if (!confirmed) {
          return;
        }
        const dropResult = dropStopById(stopId, 'manual-drop');
        if (!dropResult) {
          if (matchedPendingDrop) {
            appState.pendingDrop = null;
            renderAll();
          }
          return;
        }
        if (matchedPendingDrop) {
          appState.pendingDrop = null;
          renderAll();
        } else if (dropResult.index === appState.currentIndex) {
          advanceToNextStore();
        } else {
          renderAll();
        }
      });
    }

    const exportButton = document.getElementById('export-button');
    if (exportButton) {
      exportButton.addEventListener('click', () => {
        const poolSnapshot = computeRemainingPoolPosterior();
        const exportData = {
          runInfo: appState.itinerary,
          activeDayId: appState.dayId,
          finalStopsState: appState.stops.map((stop) => ({
            id: stop.id,
            name: stop.name,
            type: stop.type,
            arrive: stop.arrive,
            depart: stop.depart,
            score: stop.score,
            status: stop.status,
            mqa: stop.mqa ?? null,
            mqaValue: stop.mqaValue ?? null,
            decision: stop.decision ?? null,
            decisionReason: stop.decisionReason ?? null,
            posterior: serializePosterior(stop.posterior),
          })),
          tripLog: appState.log,
          posteriorPool: {
            ...serializePool(poolSnapshot),
            observedAlpha: appState.posteriorPool.observedAlpha,
            observedBeta: appState.posteriorPool.observedBeta,
            observationCount: appState.posteriorPool.observationCount,
            totalObservedQuality: appState.posteriorPool.totalObservedQuality,
          },
          posteriorConfig: appState.posteriorConfig,
        };
        const dataStr = JSON.stringify(exportData, null, 2);
        const dataBlob = new Blob([dataStr], { type: 'application/json' });
        const url = URL.createObjectURL(dataBlob);
        const a = document.createElement('a');
        a.href = url;
        const runId = appState.itinerary?.runId ?? 'trip';
        a.download = `rust-belt-trip-${runId}-results.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      });
    }
  }

  function getRecommendation(currentPosterior, poolPosterior, mqaKey, mqaValue) {
    const fallbackCurrentUcb = typeof mqaValue === 'number' ? mqaValue : null;
    const derivedCurrentUcb =
      currentPosterior && typeof currentPosterior.upper === 'number'
        ? currentPosterior.upper
        : null;
    const currentUcb = derivedCurrentUcb ?? fallbackCurrentUcb;
    const derivedRemainingUcb =
      poolPosterior && typeof poolPosterior.upper === 'number'
        ? poolPosterior.upper
        : null;
    const fallbackRemainingUcb =
      poolPosterior && typeof poolPosterior.mean === 'number'
        ? poolPosterior.mean
        : null;
    const remainingUcb = derivedRemainingUcb ?? fallbackRemainingUcb;
    const observationCount = currentPosterior?.observationCount ?? 0;

    if (mqaKey === 'Bust') {
      const diff =
        currentUcb != null && remainingUcb != null ? currentUcb - remainingUcb : currentUcb ?? null;
      return {
        decision: 'Leave',
        reason: 'mqa-bust',
        diff,
        zScore: null,
        currentUcb,
        remainingUcb,
        observationCount,
      };
    }

    if (!currentPosterior || currentUcb == null) {
      return {
        decision: 'Leave',
        reason: 'no-current-posterior',
        diff: null,
        zScore: null,
        currentUcb,
        remainingUcb,
        observationCount,
      };
    }

    if (!poolPosterior || poolPosterior.count === 0 || remainingUcb == null) {
      return {
        decision: 'Stay',
        reason: 'no-remaining-stops',
        diff: currentUcb,
        zScore: null,
        currentUcb,
        remainingUcb,
        observationCount,
      };
    }

    const diff = currentUcb - remainingUcb;
    const combinedStd = Math.sqrt(
      currentPosterior.std * currentPosterior.std + poolPosterior.std * poolPosterior.std,
    );
    const zScore =
      combinedStd > 0
        ? diff / combinedStd
        : diff >= 0
        ? Number.POSITIVE_INFINITY
        : Number.NEGATIVE_INFINITY;

    if (diff > 0) {
      return {
        decision: 'Stay',
        reason: 'ucb-favors-current',
        diff,
        zScore,
        currentUcb,
        remainingUcb,
        observationCount,
      };
    }

    return {
      decision: 'Leave',
      reason: diff === 0 ? 'ucb-tie' : 'ucb-favors-remaining',
      diff,
      zScore,
      currentUcb,
      remainingUcb,
      observationCount,
    };
  }

  function computeRemainingPoolPosterior(excludeId) {
    const remainingStops = appState.stops.filter(
      (s) => s.status === 'tovisit' && (!excludeId || s.id !== excludeId),
    );

    let pseudoAlpha = 0;
    let pseudoBeta = 0;
    remainingStops.forEach((stop) => {
      const priorNorm = stop.posterior?.priorNormalized ?? normalizeScore(stop.score);
      const pseudo = stop.posterior?.pseudo ?? appState.posteriorConfig.priorStrength;
      pseudoAlpha += priorNorm * pseudo;
      pseudoBeta += (1 - priorNorm) * pseudo;
    });

    const alpha = appState.posteriorConfig.baseAlpha + pseudoAlpha + appState.posteriorPool.observedAlpha;
    const beta = appState.posteriorConfig.baseBeta + pseudoBeta + appState.posteriorPool.observedBeta;
    const stats = computeBetaStats(alpha, beta);
    return {
      ...stats,
      count: remainingStops.length,
      pseudoAlpha,
      pseudoBeta,
      observationCount: appState.posteriorPool.observationCount,
      totalObservedQuality: appState.posteriorPool.totalObservedQuality,
    };
  }

  function createPosterior(baseScore) {
    const normalized = normalizeScore(baseScore);
    const pseudo = appState.posteriorConfig.priorStrength;
    const posterior = {
      alpha: appState.posteriorConfig.baseAlpha + normalized * pseudo,
      beta: appState.posteriorConfig.baseBeta + (1 - normalized) * pseudo,
      priorNormalized: normalized,
      pseudo,
      observationCount: 0,
      totalQuality: 0,
      lastObservation: null,
    };
    return recomputePosteriorStats(posterior);
  }

  function updateStopPosterior(stop, mqaValue) {
    const normalized = normalizeScore(mqaValue);
    stop.posterior.alpha += normalized;
    stop.posterior.beta += 1 - normalized;
    stop.posterior.observationCount = (stop.posterior.observationCount ?? 0) + 1;
    stop.posterior.totalQuality = (stop.posterior.totalQuality ?? 0) + mqaValue;
    stop.posterior.lastObservation = mqaValue;
    recomputePosteriorStats(stop.posterior);
  }

  function updatePoolObservation(mqaValue) {
    const normalized = normalizeScore(mqaValue);
    appState.posteriorPool.observedAlpha += normalized;
    appState.posteriorPool.observedBeta += 1 - normalized;
    appState.posteriorPool.observationCount += 1;
    appState.posteriorPool.totalObservedQuality += mqaValue;
    appState.posteriorPool.lastObservation = mqaValue;
  }

  function recomputePosteriorStats(posterior) {
    posterior.alpha = Math.max(posterior.alpha, EPSILON);
    posterior.beta = Math.max(posterior.beta, EPSILON);
    const total = posterior.alpha + posterior.beta;
    const meanNormalized = posterior.alpha / total;
    const varianceNormalized = (posterior.alpha * posterior.beta) / ((total + 1) * total * total);
    const stdScore = Math.sqrt(Math.max(varianceNormalized, 0)) * SCORE_RANGE;
    posterior.meanNormalized = meanNormalized;
    posterior.mean = denormalizeScore(meanNormalized);
    posterior.std = stdScore;
    posterior.lower = clamp(
      posterior.mean - appState.posteriorConfig.credibleZ * stdScore,
      SCORE_MIN,
      SCORE_MAX,
    );
    posterior.upper = clamp(
      posterior.mean + appState.posteriorConfig.credibleZ * stdScore,
      SCORE_MIN,
      SCORE_MAX,
    );
    posterior.variance = stdScore * stdScore;
    return posterior;
  }

  function computeBetaStats(alpha, beta) {
    const safeAlpha = Math.max(alpha, EPSILON);
    const safeBeta = Math.max(beta, EPSILON);
    const total = safeAlpha + safeBeta;
    const meanNormalized = safeAlpha / total;
    const varianceNormalized = (safeAlpha * safeBeta) / ((total + 1) * total * total);
    const stdScore = Math.sqrt(Math.max(varianceNormalized, 0)) * SCORE_RANGE;
    const meanScore = denormalizeScore(meanNormalized);
    const lower = clamp(
      meanScore - appState.posteriorConfig.credibleZ * stdScore,
      SCORE_MIN,
      SCORE_MAX,
    );
    const upper = clamp(
      meanScore + appState.posteriorConfig.credibleZ * stdScore,
      SCORE_MIN,
      SCORE_MAX,
    );
    return {
      alpha: safeAlpha,
      beta: safeBeta,
      meanNormalized,
      mean: meanScore,
      std: stdScore,
      variance: stdScore * stdScore,
      lower,
      upper,
    };
  }

  function serializePosterior(posterior) {
    return {
      alpha: posterior.alpha,
      beta: posterior.beta,
      mean: posterior.mean,
      meanNormalized: posterior.meanNormalized,
      std: posterior.std,
      variance: posterior.variance,
      lower: posterior.lower,
      upper: posterior.upper,
      observationCount: posterior.observationCount ?? 0,
      totalQuality: posterior.totalQuality ?? 0,
      lastObservation: posterior.lastObservation ?? null,
      priorNormalized: posterior.priorNormalized ?? null,
      pseudo: posterior.pseudo ?? appState.posteriorConfig.priorStrength,
    };
  }

  function serializePool(poolPosterior) {
    return {
      alpha: poolPosterior.alpha,
      beta: poolPosterior.beta,
      mean: poolPosterior.mean,
      meanNormalized: poolPosterior.meanNormalized,
      std: poolPosterior.std,
      variance: poolPosterior.variance,
      lower: poolPosterior.lower,
      upper: poolPosterior.upper,
      count: poolPosterior.count,
      pseudoAlpha: poolPosterior.pseudoAlpha,
      pseudoBeta: poolPosterior.pseudoBeta,
      observationCount: poolPosterior.observationCount,
      totalObservedQuality: poolPosterior.totalObservedQuality,
    };
  }

  function setText(id, value) {
    const el = document.getElementById(id);
    if (!el) return;
    el.textContent = value;
  }

  function normalizeScore(value) {
    const safeValue = typeof value === 'number' ? value : appState.posteriorConfig.defaultScore;
    return clamp((safeValue - SCORE_MIN) / SCORE_RANGE, 0, 1);
  }

  function denormalizeScore(normalized) {
    return SCORE_MIN + clamp(normalized, 0, 1) * SCORE_RANGE;
  }

  function formatScore(value) {
    if (typeof value !== 'number') return '0.0';
    return value.toFixed(1);
  }

  function clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  function humanizeReason(reason) {
    if (!reason) return '';
    const text = reason
      .replace(/[-_]/g, ' ')
      .replace(/\b([a-z])/g, (m) => m.toUpperCase());
    return text
      .replace(/\bMqa\b/g, 'MQA')
      .replace(/\bUcb\b/g, 'Upper Confidence Bound (UCB)');
  }
})();
</script>
